This is a lesson to learn and underestand Kotlin programming language
Kotlin JVM - Kotlin Java Virtual Machine
JVM was initially written to run java code, but right now other newer languages that can be accepted have emerged e.g
Scalar
Groovy
Kotlin

SDK - Software Developement Kit
JDK - Java Develoopement Kit

Remember that the main function is written as fun main() while in C it is public static void main
fun is the keyword used to declare a new function
main is the name of the function - it is the entry point into the aplication
function takes arguments sorrounded by carly brackets
We do not have a semi-colon at the end of the statements in kotlin, we can add them but it is very discouraged

Lower case starting while naming variables is called CAMELCASE
While upper case first letters are called PASCALCASE

The difference between print and println is that print does not add a line break at the end of the statement that is being written
kotlin declaration starts with the term VAR just like in javascript
Kotlin =  // Declare the variables
             var userName : String = "John paita"

            name a variable var a then colon then variable type and then give the result to it.

KOTLIN is a statically typed programming language meaning that the type of a variable is checked during compile time
whle dynamic languages the type of varibale are checked during runtime

Add curly brackets to perform some certain operations on the variables within statements eg i will be ${myAge + 2} years old

VAR stands for variable while VAL stands for VALUE the difference is that val is given to variales which we do not expect to be changed later on

TYPE INFERENCE = Kotlin has this feature
it means that the compilere can see what type of a value we try to assign to varibale and we do not have to tell it explicitly

val example = 56
Here 56 is called a literal because it always consists of a literal representation of the exact number, like it will never be 26 here for example or even 20
In kotlin Char has 1 single quote while String has double quotes

Inside the curly brackets you can only put there expressions and not anything else

                                        REAL

Read Input
Evaluate Input
Print
Loop

Basic arrays example
fun arrays() {
    val arrayOfNames = arrayOf("John", "paita", "Mabonga")
    print(arrayOfNames[0])
}


FOR LOOP AND RANGES
These are used to avoid repetition by performing code multiple times


DEFAULT AND NAME D ARGUMENTS
Default arguments are applied in function where a value is already defined and passing it is not compulsary
Named values are where the values are defined inside the calling method

VARAG AND SPREAD OPERATOR
VARARG - This stands for variabole arguments
SPREAD operator is the hesteric added before a variable
It is important to not e that a function can only accept one vararg paramere
The last parameter should always be the varag

CLASSES IN KOTLIN
While assigning values to the variables, declaration of the key word NEW is never necessary at all


RECYCLERVIEW TUTORIAL WITH KOTLIN
In the first activity prepare an XML layout, add the recycler view to carry the list (A recycler view is where peoople will see it)
Now open another xml file and prepare the layout for each of the item present in the list, taking note of the ids - describes how
each item seen by users on the RecyclerView will look like
Prepare a data model that will hold the data
Prepare a custom adapter class that will be able to to bind the data and define it's behaviors when loaded
Link the custom adapter with the recyclerview

First of all create an adapter

class HobbiesAdapter {


}

VIEWHOLDER CLASS

First of all define a regular class and give it a regular name

class HobbiesAdapter {

}

A ViewHolder describes an item view and metadata about its place within the RecyclerView. It is basically just a superclass
In order to bind the data to the each of the view, we need to have a ViewHolder Class here called myViewHolder
ViewHolder Class = Helps bind data to each of the view, so it is a class which accepts a parameter of each item view of type View
So the viewholder is an inner class, which accepts the itemView which is an object of type view as its parameter

class HobbiesAdapter {
	inner class MyViewHolder (itemView : View){
	}
}

Now since the inner viewholder class MyViewHolder is supposed to bind data to the recyclerView, it makes sense that it has to extend
inner class of RecyclerView.ViewHolder,
So let us add it.

class HobbiesAdapter {
	inner class MyViewHolder (itemView : View) : RecyclerView.ViewHolder(){
	}
}

We need to pass the itemVIew to the RecyclerView.ViewHolder constructor as follows

class HobbiesAdapter {
	inner class MyViewHolder (itemView : View) : RecyclerView.ViewHolder(itemView){
	}
}

Now the top level class will take a superclass adapter class which is the myViewHolder which we just prepared there,

REMINDER
The class needs an innerclass my viewholder which accepts itemView - the view which it holds and it extenends the RecyclerView.ViewHolder class
which accepts the itemView
While the main class will extend a superclass RecyclerView.Adapter<> which accepts the ViewHolder we just created, myViewHolder
Let us now add it there.

class HobbiesAdapter : RecyclerView.Adapter<myViewHolder> {
	inner class MyViewHolder (itemView : View) : RecyclerView.ViewHolder(itemView){
	}
}

Since myViewHolder is an innerclass, how shall we accept it then? BY passing HobbiesAdapter.myViewHolder to it as follows

class HobbiesAdapter : RecyclerView.Adapter<HobbiesAdapter.myViewHolder> {
	inner class MyViewHolder (itemView : View) : RecyclerView.ViewHolder(itemView){
	}
}

Now let us add the constructor at the end. It looks like this : ()

class HobbiesAdapter : RecyclerView.Adapter<myViewHolder> () {
	inner class MyViewHolder (itemView : View) : RecyclerView.ViewHolder(itemView){
	}
}

And now an error will appear you need to overwrite all the 3 abstract methods of the RecyclerViewVIew.Adapter<>() class in our subclass
of HobbiesAdapter

User Alt + Enter to AutoGenerate


class HobbiesAdapter : RecyclerView.Adapter<myViewHolder> () {
	inner class MyViewHolder (itemView : View) : RecyclerView.ViewHolder(itemView){
		override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): myViewHolder {

		}

		override fun getItemCount(): Int {

		}

		override fun onBindViewHolder(holder: myViewHolder, position: Int) {

		}
	}
}

Good, now since we are going to access our top level class HobbiesAdapter from our HobbiesActivity, we are going to pass 2 parameters
1.The context of typer Context of the calling activity, and
2.The list of hobbies that needs to be inflated in our RecyclerView, we prepared a data class containing that list of hobbies

Remember it looked like this??
//First we declare the data class
data class Hobby(var tittle: String)

object Supplier {
    val hobbies = listOf(
        Hobby("Swimming"),
        Hobby("Eating"),
    )
}

class HobbiesAdapter(context : Context, hobbies : <Hobby>) : RecyclerView.Adapter<myViewHolder> () {
	inner class MyViewHolder (itemView : View) : RecyclerView.ViewHolder(itemView){
		override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): myViewHolder {

		}

		override fun getItemCount(): Int {

		}

		override fun onBindViewHolder(holder: myViewHolder, position: Int) {

		}
	}
}

Now analyse the methods that we have overwritten

 1.GetItemCount
 As the name suggests, this method will return the number of objects in hobbies list so we pass return hobbies.size to it.

 class HobbiesAdapter(context : Context, hobbies : <Hobby>) : RecyclerView.Adapter<myViewHolder> () {
	inner class MyViewHolder (itemView : View) : RecyclerView.ViewHolder(itemView){
		override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): myViewHolder {
		}

		override fun getItemCount(): Int {
			return hobbies.size
		}

		override fun onBindViewHolder(holder: myViewHolder, position: Int) {

		}
	}
}

2.Oncreate ViewHolder
This method is simply responsible for creating each of the viewholder items ie each row as it appears in the recyclerview
so in order to create the view we need to import listitem. xml
We do this using LayoutInflater method which returns the view that we want to be used to have the viewholder items appear as
We prepared a list of objects in the xml, remember?
Now it looks like this


class HobbiesAdapter(context : Context, hobbies : <Hobby>) : RecyclerView.Adapter<myViewHolder> () {


 RecyclerView.Adapter<HobbiesAdapter.myViewHolder>() {
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): myViewHolder {
        //Combine the data with the views so instead of getting my title, we get the list of hobbies
        val view = LayoutInflater.from(context).inflate(R.layout.list_item, parent, false)
        return myViewHolder(view)
    }

    override fun getItemCount(): Int {
        return hobbies.size
    }

    override fun onBindViewHolder(holder: myViewHolder, position: Int) {

    }

	inner class MyViewHolder (itemView : View) : RecyclerView.ViewHolder(itemView){

	}
}

3.BindViewHolder
Responsible for binding all the data to the views that are being created there, so now it makes sense that we retrieve our current Hobby object
val hobby = hobbies [position]
We then use holder which is an instance of myViewHolderClass  to set the data.

RecyclerView.Adapter<HobbiesAdapter.myViewHolder>() {
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): myViewHolder {
        //Combine the data with the views so instead of getting my title, we get the list of hobbies
        val view = LayoutInflater.from(context).inflate(R.layout.list_item, parent, false)
        return myViewHolder(view)
    }

    override fun getItemCount(): Int {
        return hobbies.size
    }

    override fun onBindViewHolder(holder: myViewHolder, position: Int) {
	val hobby = hobbies.position[position]
	holder.setdata(hobby , position)
    }

	inner class MyViewHolder (itemView : View) : RecyclerView.ViewHolder(itemView){

	}
}

Now create the set data method within the myViewHolder Class, and within that method , we use itemView - which is the view of each of the layout
itemView.txvTittle.text = hobby.tittle to bind the text to it
fun setData(hobby : Hobby?){
	itemView.txvTitle.text = hobby.tittle
}

Moving on, you it will look like this;

RecyclerView.Adapter<HobbiesAdapter.myViewHolder>() {
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): myViewHolder {
        //Combine the data with the views so instead of getting my title, we get the list of hobbies
        val view = LayoutInflater.from(context).inflate(R.layout.list_item, parent, false)
        return myViewHolder(view)
    }

    override fun getItemCount(): Int {
        return hobbies.size
    }

    override fun onBindViewHolder(holder: myViewHolder, position: Int) {
	val hobby = hobbies.position[position]
	holder.setdata(hobby , position){
		itemView.txvTitle.text = hobby.tittle
    }

	inner class MyViewHolder (itemView : View) : RecyclerView.ViewHolder(itemView){

	}
}



Kotlin Coroutines
They are used when you need to do some work ont the backgroudn thread

if you are making a request to the network eg Volley or Retrofit
Accessing the internal requests	SQLITE database

//Use a coroutine to simulatae a network or room request
The susprend is a coroutines key word
Suspend marks something that it can be asynchronous, not necessality on a aback groudn thread or main thread
it just helps you to be able to call them from a coroutine


Corotine Scopes
Is a way to organize corroutines into groups


//lateinit is a way to declare something without it being initialized until you initialize it yourself
It extends the Completable Job Object and the difference between a completable job object and a regular job object is that
the earlier has more functionality assigned to it

private lateinit var job : CompletableJob






